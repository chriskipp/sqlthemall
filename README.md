# sqlthemall

sqlthemall provides automatic generation of relational database schemes based on the structure of provided JSON objects as well as their direct import into the (relational) database of your choice.

## Installation

### Dependencies

- [SQLalchemy](https://www.sqlalchemy.org) Since sqlthemall uses to access the different databases this package is mandatory.
- [alembic](https://github.com/sqlalchemy/alembic) To change tables that are already created.
- [ujson](https://github.com/ultrajson/ultrajson) To speed up the parsing of JSON objects. If installed it will be used as a replacement for the `json` module of the standart library. This package is a optional dependency.

### Setup

***Please make sure that you set up a virtual environment before instlling
this package directly to your system environment. Due to breaking changes in
the different versions of `SQLalchemy` this could effect other programms that
might rely on other versions.***

This package and all dependencies can be installed via:
```bash
python3 -m pip install .
```

While SQLalchemy generally supports a wide range of different databases the standard installation of SQLalchemy only supports SQLite. To be able to use other data bases you might wish to install further python packages providing SQLalchemy support for the database of your choice. You can find a quick overview of supported databases as well as installation instructions for their SQLalchemy support [here](https://apache-superset.readthedocs.io/en/latest/installation.html#database-dependencies).

## Usage

### Quickstart

After installation you should be able to run the following command:

```bash
sqlthemall -s -f data/example.json -d 'sqlite:///example.sqlite'
```
This will recursively parse the JSON data in the file `data/example.json` and generate the following database schema:

![simple schema](img/example.svg)
Image generated by [sadisplay](https://github.com/GoodRx/sadisplay) (requires sadisplay and graphviz):

```bash
sadisplay --url 'sqlite:///example.sqlite' | dot -Tsvg > img/examplesvg.
```

The command expects a `-d/--databaseurl "database://user:password@host:port"` option as a mandatory argument as well as either the `-f/--file my_file.json` or the `-u/--url https://my_awesome_json_api.json` option as a source to read the JSON data from (if both are omitted it tries to read a JSON data from stdin).

To make full use of the abilities of relational databases skip the `-s` option to create a database schema containing bridge tables to support many-to-many relationships.

```bash
sqlthemall -d 'sqlite:///countries.sqlite' -u 'https://restcountries.com/v2/all' -t 'countries'
```

The above command will download the JSON data returned by the API request. Beside the root_taable table (named 'countries' throucg the -c option) containing the database entries for the countries itself, all the data provided in the JSON document is represented as a set of country related tables such as used currencies, spoken languages, time zones, ... The relations between the different types of database objects are represented in the form of foreign keys/bridge tables. 

![restcountries database schema](img/countries.svg)

### Further command line options

The behaviour of `sqlthemall` can be further adjusted by several command line options. The Usage is:

```
usage: sqlthemall [-h] -d DBURL [-u URL] [-f FILE] [-s] [-n] [-a] [-L {ERROR,WARNING,INFO,DEBUG}]
                  [-p] [-e] [-t ROOT_TABLE] [-l] [-S] [-N BATCH_SIZE]

optional arguments:
  -h, --help            show this help message and exit
  -d DBURL, --databaseurl DBURL
                        Database url to use
  -u URL, --url URL     URL to read JSON from
  -f FILE, --file FILE  File to read JSON from (default: stdin)
  -s, --simple          Creates a simple database schema (no mtm)
  -n, --noimport        Only creates database schema, skips import
  -a, --autocommit      Opens database in autocommit mode
  -L {ERROR,WARNING,INFO,DEBUG}, --loglevel {ERROR,WARNING,INFO,DEBUG}
                        Set the log level
  -p, --no_progress     Do not print progress while importing
  -e, --echo            Print SQL statements (engine.echo = True)
  -t ROOT_TABLE, --root-table ROOT_TABLE
                        Name of the table to import the outermost subobjects if JSON object is a
                        array
  -l, --line            Uses JSONline instead of JSON
  -S, --sequential      Processes objects in JSONline mode in sequential order
  -N BATCH_SIZE, --batch_size BATCH_SIZE
                        Number of objects processed per commit in sequential mode
```

## Usage Hints/Where to go from here?

While sqlthemall provides the generation of a database scheme as well as the import of data in the JSON format, you might want to use it in combination with software from other repositories:
- [sadisplay](https://github.com/GoodRx/sadisplay) allows you to display the generated database schemes. In combination with sqlthemall this allows you to quickly get a overview of the structure of JSON data
- [sqlcodegen](https://github.com/agronholm/sqlacodegen) automatically generates the code for SQLAlchemy style python classes that allow directly access of the imported data in a object oriented manner
- [public-apis](https://github.com/public-apis/public-apis) provides a list of public API's that allow you to retrieve a wide variaty of JSON data

## Why this program?

Practically almost all of the data provided via web API's is provided as JSON. While JSON is a hierarchical data format (which means it can have nested (sub)objects as well as (sub)arrays) it is not directly possible to transform such data structures in a purely (single) tabular form (for example as a single CSV file).

In contrast to formats like CSV, relational databases have the ability to provide relations between different types of objects and the relations in between them through foreign keys and/or bridge tables.
Since the import of JSON data into relational databases is usually still a manual process which can be very time consuming, depending on the complexity of the provided JSON data, this repository tries to automatize this process as far as possible. You should keep in mind that there is not the "one and only" correct way to represent the structure of a certain data set as a relational schema. The generated database schemes therefore are a direct representation of the structure inherited by the given JSON data.
